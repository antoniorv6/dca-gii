---
title: "Proyecto para Desarrollo Colaborativo de Aplicaciones"
description: "Un videojuego 2D en C++ con Raylib"
order: 2
--- 
## Un videojuego 2D en C++ con Raylib

Durante todo el curso de _Desarrollo Colaborativo de Aplicaciones_ semanas, os convertiréis en un equipo de desarrollo de videojuegos con la misión de diseñar y programar un juego 2D para PC utilizando `C++` y librerías auxiliares. Principalmente, desarrollaréis vuestro juego a través de _raylib_ una librería programada en `C` que contiene un ámplio abanico de funciones y posibilidades para desarrollar un videojuego de forma sencilla e intuitiva.

No se trata de una práctica pequeña: vais a enfrentaros, de una forma controlada, a un reto de desarrollo _software_. Deberéis organizaros en equipo, repartir responsabilidades, tomar decisiones de diseño, y sobre todo… ¡aseguraros de acabar con un juego jugable!

---

## Trabajo en equipo

- Los grupos estarán formados por **tres o cuatro personas**.

- Cada miembro debe tener un rol bien definido (aunque flexible) en el proyecto: programación de mecánicas, gestión de gráficos, integración de audio, etc. **El juego debe contar con envergadura suficiente para que, al menos, cada componente del grupo tenga una responsabilidad**. Algunas ideas sobre sectores que se pueden asignar:
    - Gráficos.
    - Sonido.
    - Mecánicas jugables.
    - Físicas (si las hay).
    - IA (comportamiento de los NPCs u obstáculos).
    - Motor de juego (Gestión de ECS).

El proyecto se gestionará en un repositorio compartido en GitHub, donde deberéis adoptar una estrategia de gestión de ramas y _commits_ estructurada, tal y como se explicará en el **Tema 2** de la asignatura.

## Sobre la idea a desarrollar

No se trata de inventar el próximo _Elden Ring_ o desarrollar el nuevo _GTA_. El proyecto debe ser viable de desarrollar en un mes y medio: lo suficiente para producir algo divertido, pero no para un proyecto de gran escala.

Para acertar con la idea, os recomendamos:

- Inspiraros en juegos retro de 16 bits o anteriores (Pac-Man, Tetris, Bomberman, Galaga, Donkey Kong…).

- Mirar juegos sencillos de móviles (Doodle Jump, Crossy Road…).

- **Tomar una mecánica simple y darle un giro propio** (ejemplo: un Tetris con piezas que explotan, un Pac-Man cooperativo, un Flappy Bird con enemigos).

> Importante: la idea debe ser validada por el profesor antes de comenzar el desarrollo. Esto servirá para asegurar que la carga de trabajo sea realista y que el juego sea viable en el tiempo establecido.

---

## Requisitos obligatorios del proyecto

Para que el proyecto se considere completo, el juego debe cumplir con los siguientes puntos obligatorios:

### Requisitos del juego

- **Gestión de estados**:
    - El juego contendrá **como mínimo** tres pantallas:
        1. Menú principal.
        2. Pantalla principal del juego.
        3. _Game over_.
    
    **Cualquier pantalla adicional se valorará positivamente**.

- **Gráficos**:
    - El juego debe tener personajes, objetos o escenarios representados con sprites.
    - Se debe implementar un gestor de contenido multimedia para no cargar repetitivamente el mismo recurso gráfico que consumen distintas entidades.

- **Mecánica principal**
    - El juego debe girar alrededor de una dinámica reconocible (ejemplo: esquivar obstáculos, disparar a enemigos, resolver puzzles, saltar plataformas, toma de decisiones).
    - No basta con mostrar gráficos en pantalla: debe existir una interacción significativa con el jugador.

### Requisitos técnicos

 - **Sistema e gestión y _bugtracking_**:
Los proyectos deberán contar con un sistema de gestión para monitorizar el avance de las tareas y los responsables de cada una de ellas, al igual que una gestión organizada de notificaciones sobre _bugs_ y problemas que se den en cada versión del _software_ proporcionado.

- **Empaquetado y portabilidad**:
El juego debe contar con al menos dos versiones ejecutables en sistemas operativos distintos, se recomienda que se centre el desarrollo en dos sistemas operativos: 
    - Linux
    - Windows

Siempre se deberá, para cada versión de la aplicación, entregar una _release_ del _software_ a través del sistema de despliegue de GitHub.

- **Internacionalización**:
El juego deberá contar con soporte para, al menos, dos idiomas. Se recomienda que estos sean **Inglés** y **Español**.

- **Suite de tests**: El juego debe de contar con una suite de, al menos, diez _tests_ para comprobar que las funcionalidades básicas no se perturban durante el desarrollo del proyecto. 

- **CI/CD y versionado del juego**:
El repositorio deberá contar con uno o varios _workflows_ que permitan que, a través de GitHub Actions, al realizar un _commit_ en la rama principal del repositorio, ejecutar diversos tests para evaluar la salida de una nueva versión del proyecto, al igual que un 

## Requisitos secundarios

El cumplimiento de estos requisitos aportarán valor al proyecto realizado y se tendrán en cuenta **positivamente**.

- **Patrón ECS**:
    - Patrón de diseño estándar de desarrollo de videojuegos.
    - Se gestionará a través de la librería _EnTT_, la cual se explicará en las sesiones de prácticas. 

- **Inteligencia Artificial**:
    - Implementación de un sistema que gestione el comportamiento de los NPCs de nuestro juego.
    - Se recomienda revisar estándares en la industria: Árboles de Decisión, _Steering behaviors_, etc.

- **Logging avanzado**:
    - Usar `cout` en un proyecto a gran escala no es una práctica muy profesional. Para ello, lo mejor es implementar unsistema de _logs_ gestionado por el propio motor del juego.
    - Recomendamos que revises la librería [spdlog](https://github.com/gabime/spdlog) para gestionar esto.

- **Interfaz de debug**: En videojuegos, a veces hay que probar _en directo_ el efecto de algunos parámetros sobre la jugabilidad. Por ejemplo, la velocidad a la que se mueve nuestro personaje, lo alto que salta... etc. Este proceso se vuelve tedioso si debemos modificar y recompilar el proyecto cada vez que hacemos un cambio. Lo ideal es habilitar un _Interfaz de debug_ para modificar, a través de un interfaz gráfico, esas variables en tiempo real. Una aplicación estándar para esto es [ImGUI](https://github.com/ocornut/imgui). Aunque la versión oficial está destinada a aplicaciones de OpenGL con GLFW, existen [adaptaciones](https://github.com/raylib-extras/rlImGui) para raylib, ¡échale un vistazo!

- **Sistema de físicas avanzado**: A veces, programar las físicas de un juego, incluso en 2D, es una tarea compleja. Una opción es usar y gestionar una librería de físicas avanzadas para trabajar este aspecto. Se recomienda la librería de [Box2D](https://box2d.org/) para implementar estas funcionalidades.

- **Gestión de múltiples _inputs_**: El teclado y el ratón no es lo único que se usa en videojuegos. A veces, los jugadores prefieren utilizar un mando para jugar sus juegos. Se valorará la creación de un gestor de múltiples _inputs_ y que el jugador decida qué esquema de control quiere usar.

- **Multijugador local**: Donde cabe una persona, caben dos. Gestiona tanto _inputs_ como entidades para que varios jugadores puedan jugar tu juego. 

- **Cualquier idea que se os ocurra**: Muchas veces, existen funcionalidades, requisitos o desafíos de implemntación que no se contemplan. Si se os ocurre alguna idea que aporte valor a vuestro juego...¡consultadle al profesor!

## Modo de trabajo
Ahora mismo, verás que hay muchas tareas por cumplir y trabajar. Sin embargo, el funcionamiento de la asignatura irá a través de **tres entregas parciales** con la solicitud de varios requisitos obligatorios y funciones según la **progresión en la teoría de la asignatura**. Esto es solo un documento general para que comprendas los objetivos globales y secundarios de la práctica. 

**El cumplimiento de los requisitos secundarios se tendrán en cuenta positivamente a la hora de calcular la nota final del proyecto**

## Documentación y entregas

A cada entrega parcial, siempre se asociará a una _release_ del proyecto. En estos casos especiales, se dará:

- El código fuente de la aplicación.
- Los ejecutables requeridos para PC.
- Documentación requerida en un fichero `Markdown` donde se resuelvan todos los ejercicios, preguntas y se documenten cuestiones relativas al progreso del proyecto. 

## Evaluación

La evaluación de las entregas parciales siempre consistirá en los siguientes puntos:

- Cumplimiento de la lista de tareas solicitada.
- Contestación satisfactoria a las preguntas relacionadas con la entrega.
- Ausencia de errores de compilación del proyecto. Los **bugs** de ejecución se deberán documentar SIEMPRE.
- Calidad del código producido, uso de buenas prácticas de programación y limpieza/documentación del programa.

**Advertencia**:

En caso de que surjan y se notifiquen dificultades en la colaboración dentro de los grupos, como por ejemplo una participación desequilibrada o el incumplimiento de tareas asignadas, se reserva la posibilidad de revisar la situación y, si fuera necesario, establecer ajustes en la calificación. Dichos ajustes podrán implicar la asignación de porcentajes diferenciados en la nota final de los estudiantes involucrados, con el objetivo de asegurar una evaluación justa que refleje el grado real de compromiso y aportación de cada integrante.


---
title: "Práctica 0: Desarrollo de Flapy Bird con raylib"
description: "Desarrollo de Flapy Bird con raylib"
order: 1
---
En esta práctica vamos a desarrollar una versión básica del clásico Flappy Bird utilizando [raylib](https://www.raylib.com/), una librería gráfica sencilla y muy didáctica para el desarrollo de videojuegos con C/C++.

El objetivo es comprender los componentes básicos del desarrollo de videojuegos, como son el bucle de juego, el manejo de entradas de teclado, el dibujo de _sprites_, el manejo de colisiones y las transiciones de estados.

## Entrega

Deberás entregar el proyecto como ejercicio en las entregas de UACloud. Para ello, comprime en `p0_<tu_DNI>.tar.gz` y súbelo a la práctica creada en el campus virtual. **La fecha límite de entrega de esta práctica es el próximo 1 de octubre de 2025**. 

## Preparación del proyecto

En primer lugar, debes utilizar la **plantilla** de videojuegos proporcionada en la [asignatura](https://github.com/antoniorv6/DCAGII-Game-Template). Para ello, crea tu repositorio a través de la opción de _Use this template_ en GitHub y clona tu repositorio en local.

Esta plantilla contiene la máquina de estados para manejar las distintas pantallas del luego, la cual habremos visto en clase. A este proyecto le deberas incluir las carpetas `assets`, `vendor/include`, `vendor/lib`. El proyecto se te debe quedar de la siguiente forma:

```
flappy_bird/
├─ assets/
├─ src/
│  └─ ...
└─ vendor/
   ├─ include/
   └─ lib/
```

### Añadir `raylib` al proyecto

La librería de `raylib` utiliza tanto dependecias de include como librerías estáticas. Por lo tanto, debemos compilar el programa y guardar estas dependencias para desarrollar nuestro _software_. En primer lugar, clonaremos el repositorio y lo compilaremos.

```bash
git clone https://github.com/raysan5/raylib.git
cd raylib/src
make PLATFORM=PLATFORM_DESKTOP
``` 
Copia `libraylib.a` a `flappy/vendor/lib/` y los ficheros `raylib.h`, `raymath.h`, `rlgl.h` a `flappy/vendor/include/`.

> No es necesario que conserves la carpeta que has clonado de raylib, ya que solo nos interesan los ficheros de cabecera y las librerías que hemos generado.

## Recomendación

Es recomendable que busques y analices bien la documentación y los ejemplos de `raylib`, ya que te ayudarán bastante para comprender y desarrollar bien esta práctica. Los enlaces son los siguientes:

- [Cheatsheet](https://www.raylib.com/cheatsheet/cheatsheet.html)
- [Ejemplos](https://www.raylib.com/examples.html)

## Ejercicio 0: creación de ventana

El primer paso a dar en la creación de un videojuego es la inicialización de la ventana. En este caso, deberás seguir los siguientes pasos:

- En `main.cpp` debes llamar, antes del bucle, a la función `InitWindow()`, la cual te permitirá crear la ventana por la que se visualizará tu juego. Crea una ventana de tamaño 288 x 512.
- En `MainGameState` deberás actualizar la función de `render` y poner algo. En este caso, vamos a introducir un texto que diga _Bienvenido a Flappy Bird DCA_. 
    - Primero, debes invocar a la función `BeginDrawing` de _raylib_.
    - Después, llama a la función `ClearBackground`, de esta forma, limpiarás todo lo que se haya dibujado en el fotograma anterior (y evitarás el famoso _trailing_ involuntario).
    - Después, llama a `DrawText` para poner tu texto en la pantalla.
    - Finalmente, llama a `EndDrawing` para finalizar el render.

Para usar estas funciones, deberás incluir la librería de _raylib_ en tu proyecto. Debido a que ésta está hecha en C (aunque es compatible con C++), deberemos importarlo de una forma especial en nuestro código. En concreto, usa el siguiente _snippet_:

```cpp
extern "C" {
    #include <raylib.h>
}
```
> ¿Por qué usamos esta estructura en especial para importar el código de _raylib_? Te recomiendo que veas [este vídeo](https://www.youtube.com/watch?v=7YBzHJJYpZo) para que tengas más información.

Ahora toca compilar. Para ello, utiliza el siguiente comando:

```sh
g++ -o game src/*.cpp -I src/ -I vendor/include/ -L vendor/lib -lraylib -lGL -lm -lpthread -lrt -lX11
```
Si ejecutas game y sale una ventana con el texto... ¡Enhorabuena! Ya tienes tu primera ventana para desarrollar tu juego.

> Si la compilación falla porque el _linker_ no encuentra alguna librería, es posible que necesites instalar en tu sistema algunas de las dependencias de _raylib_. Ejecuta `sudo apt install xorg-dev libx11-dev libxrandr-dev libxi-dev libgl1-mesa-dev libglu1-mesa-dev`.

## Ejercicio 1: mecánica principal y _render_ básico

Ahora implementaremos al pájaro y su gravedad en el juego, el cual será controlado por el jugador. Para ello, sigue los siguientes pasos.

- En primer lugar, debemos definir bien el _Delta Time_ en nuestro juego. Para ello, dentro del bucle, debes asignarle a la variable `delta_time` el valor que produce la función `GetFrameTime` de _raylib_. 

- Declara un `struct` llamado `Bird` que contiene los siguientes parámetros: 
    - `x` e `y` para su posición.
    - `vy` para su velocidad vertical.

- Crea una variable privada en el estado que sea el jugador con esa estructura.
- Inicializa al jugador con una posición fija de `(200, 200)`.
- En el método `handleInput`:
    - Si se presiona la tecla del espacio (busca la función `IsKeyPressed`), hay que impulsar al pájaro hacia arriba. Es decir, añadir un valor a `vy`. En este caso, ponle un valor de `-300`. 
- En el método `update`:
    - Aumenta la velocidad con la gravedad: `vy += gravedad * deltaTime`
    > El Delta Time se pasa como parámetro al método `update` y se calcula automáticamente por `raylib`.
    - Actualiza la posición del pájaro: `y += vy * deltaTime`
    - Reinstaura el valor de la velocidad a 0.
- En el método `render`:
    - Dibuja al pájaro como un círuclo rojo. Para ello, usa la función `DrawCircle` de `raylib`. Usa un radio de 17 píxeles.

## Ejercicio 2: ¡los tubos!

Nuestro _flappy bird_ se debe chocar contra algo... ¡vamos a implementar los tubos que debe esquivar! Para ello, debemos de renderizar unas tuberías.

Unas tuberías en realidad son un par de rectángulos que tienen la misma coordenada `x` y una separación en `y` configurable. Éstas se mueven a la misma velocidad y deben aparecer con cierta frecuencia para ser un obstáculo para el jugador.

Para implementar esto sigue los siguientes pasos:

- Define `struct PipePair { Rectangle top, bot; bool scored=false; };`.
> _raylib_ tiene una estructura de datos específica para los rectángulos, la cual nos va a venir muy bien para gestionar las físicas y las colisiones del juego.

- Crea en el estado una cola `deque` de objetos tipo `PipePair`.

- Define unas constantes para el espacio entre las tuberias, su anchura y su velocidad.

- Define una variable que sea el temporizador de tuberías `spawnTimer`y la frecuencia con la que aparecen `spawnEvery`.

- Define dos variables: `PIPE_W = 32` y `PIPE_H = 320`

Una vez definido esto, en `update` debes hacer lo siguiente:

1. Cada `spawnEvery` ciclos (medido con `deltaTime`):
    - Calcula un valor aleatorio para sacar el _offset_ de la tubería superior: `pipe_y_offset_top`. Para ello utiliza la función `GetRandomValue` de raylib. Te recomendamos que el valor máximo sea la mitad del tamaño de la pantalla (utiliza `GetScreenWidth`) y el mínimo sea la mitad de la altura de la tubería.
    - Las dos tuberías empiezan en la misma posición `x = <anchura_de_pantalla>`.
    - La tubería superior empieza en una coordenada y de `-pipe_y_offset_top`
    - La tubería inferior tiene una posición `y` de `(PIPE_H - pipe_y_offset_top) + valor_aleatorio(PIPE_H/2, <ancho_pantalla>/2)`.
    - Inserta tu nuevo objeto en la cola.

2. Mueve las tuberías que haya en la cola. Actualiza su posición en x de tal forma que `x -= PIPE_SPEED * deltaTime`.

3. Comprueba que, si las tuberías al frente de la cola se encuentran fuera de los límites de la pantalla, se borren. Para eso, usa la función `front()`de la cola y llama a `pop_front()` si la condición se cumple.

Finalmente, en la función `render`, itera sobre todas las tuberías de la cola. Usa la función `DrawRectangle` de _raylib_. Recuerda que renderizas **dos** tuberías, por lo que debes llamar dos veces a la función con los datos de cada tubería en la estructura de datos.

Deberías observar, ahora, que aparecen con frecuencia dos rectángulos verdes que se mueven progresivamente a la izquierda.

## Ejercicio 3: Colisiones y _Game Over_

Necesitamos ahora que, si el jugador choca contra una tubería o se sale de la pantalla, pierde la partida. Para ello, vamos a gestionar las colisiones con las funciones nativas de _raylib_ y actualizaremos la máquina de estados para que nos aparezca una pantalla de _Game Over_.

Para calcular las colisiones, deberemos utilizar la función `CheckColisionRecs` de _raylib_. Esta función require de dos estructuras `Rectangle` para comprobar si hay un solapamiento entre los dos. Por lo tanto, necesitamos, para todas las tuberías, verificar si el jugador ha chocado con alguna de ellas. Esto se conoce formalmente como una **colisión AABB** entre dos **bounding boxes**. ¡Para las tuberías ya tenemos el _bounding box_! Ya que las hemos definido como rectángulos. Sin embargo, necesitamos definir el del jugador.

- En la función _update_:
    - Calcula un `Rectangle` que será el bounding box del jugador. Para ello, deberás tomar como origen el centro del círculo (que es la posición en x e y menos el radio). De altura y anchura deben de ser el mismo radio.
    > Puedes _debuggear_ la colocación de esta caja renderizándola en el método _render_ a través de la función `DrawRectanglePro`
    - Crea una nueva clase `GameOverState`. En ésta, pon el fondo del mismo color que en tu pantalla principal y un texto que ponga: _Game Over_ en el centro de la pantalla. (Recuerda cómo hiciste esto en el ejercicio 0). 
    > Recuerda que debe heredar de `GameState` y, por lo tanto, sobreescribir todos los métodos virtuales (aunque estén vacíos).
    - Para todas las tuberías:
        - Comprueba si el _bounding box_ del jugador colisiona con las tuberías (debes enviar los dos `Rectangle` que ya tienes tanto precalculado como en la propia estructura de datos).
        - Si esto sucede, debes crear un nuevo estado de _GameOverState_ y mandárselo a la máquina de estados. Para ello, pon la siguiente línea:

        ```cpp
        this->state_machine->add_state(std::make_unique<GameOverState>(), true);

        ```

Con eso, ¡ya gestionamos que nuestro jugador pierda si choca contra las tuberías!

Ahora te toca, con lo que ya sabes, implementar en `GameOverState` que, si el jugador pulsa el **Espacio**, se inicie una nueva partida (¿qué deberemos hacer para cambiar de pantalla?).

## Ejercicio 4: Puntuación

Lo penúltimo que nos queda es que el jugador consiga puntos por pasar entre las tuberías. Para ello, implementaremos unas modificaciones sencillas a nuestro juego.

1. Crea una variable en el estado que sean los puntos que tiene le jugador.
2. En la función `update`, si la posición en `x` de las tuberías es menor a la del jugador (ten en cuenta la anchura de éstas), entonces debes sumar un punto.
3. En la función `render` debes de mostrar la puntuación del jugador.
    > La función `DrawText` acepta un `const char*` como entrada. Para poder convertir de un número entero a un `const char*` puedes convertirlo con std::to_string() y llamar a la función c_str() para castearlo a este tipo.

4. Envía la puntuación al estado de _Game Over_ para que lo guarde en una variable y la muestre en la pantalla.

Con todo esto... ¡ya tienes tu primer _Flappy Bird_ básico.

## Ejercicio 5: Dándole brillo al juego

Ahora que ya tienes el juego implementado, vamos a mejorar cómo se ve. Para ello, vamos a sustituir estas figuras básicas por imágenes (o también conocido en la jerga como _sprites_).

### Añadir los _assets_ al proyecto

En esta práctica, utilizaremos los _assets_ que se encuentran en el repositorio de [samuelcust](https://github.com/samuelcust/flappy-bird-assets). Para ello, clona dicho repositorio y copia el contenido de la carpeta `sprites` en `assets`. 

### Modificar el proyecto para incluir los _assets_

En primer lugar, debemos cargar los _sprites_ en nuestro programa. Para ello, utilizaremos el módulo de texturas que contiene _raylib_.

1. Añade dos propiedades más a la clase `Bird`: `height` y `width`, ya que el _bounding box_ es variable según el tamaño del _sprite_.
2. Define dos variables privadas en el estado: `birdSprite` y `pipeSprite`. Aquí será donde cargaremos nuestras texturas.
3. Las constantes definidas para las tuberías ahora deben de ser variables, asegúrate de que ningún parámetro es constante en tu implementación. Añádete también una variable `PIPE_H` para guardar la altura del _sprite_.
4. En el método `init`:
    1. Carga las texturas en las variables definidas anteriormente. Para ello, utiliza la función `LoadTexture` de _raylib_.
    2. Define el ancho y el alto del jugador a través de las propiedades `width` y `height` del _sprite_ que habéis cargado.
    3. Haz lo mismo para las variables `PIPE_W` y `PIPE_H`.
    4. Define el _gap_ de la altura de las tuberias como la altura de tu jugador más una constante. Te recomendamos poner 4.5.

5. En el método `update`:
    1. El _bounding box_ del jugador ahora será dependiente de la anchura y la altura del propio jugador, no de un radio. Actualiza esta variable con los parámetros adecuados.

6. En el método `render`:
    1. Dibuja el _sprite_ del jugador. Para eso, utiliza la función `DrawTexture` de _raylib_.
    2. Ahora vamos a dibujar los _sprites_ de las tuberías. En este caso, vamos a usar una función más compleja de la librería, ya que solamente tenemos un _sprite_ para ello. Vamos a utilizar la función `DrawTextureEx` para permitir rotar el _sprite_.
    ```cpp
    DrawTextureEx(this->pipeSprite, {p.top.x + PIPE_W, p.top.y + PIPE_H}, 180.f, 1.0f, WHITE);
    DrawTextureEx(this->pipeSprite, {p.bot.x , p.bot.y}, 0.f, 1.0f, WHITE);
    ```

## Extras

Con todo esto, ya deberías tener un conocimiento básico para desenvolverte en las prácticas de la asignatura. De todas formas, aquí tienes unos cuantos ejercicios extra que puedes intentar para mejorar la implementación de este juego y ampliar tus conocimientos sobre la librería de _raylib_.

1 - Añade sonidos al juego. Puedes encontrar los efectos en el mismo [repositorio](https://github.com/samuelcust/flappy-bird-assets/tree/master/audio) donde has descargado los _sprites_. Revisa los [los ejemplos](https://www.raylib.com/examples.html) de _raylib_ para ello.

2 - Añade la dificultad progresiva. ¿Qué deberías actualizar del estado principal para que los huecos entre las tuberias sean más pequeños y éstas vayan más rápido?

3 - Renderiza la puntuación a través de _sprites_. Tienes los recursos en la carpeta _assets_.

4 - ¡Atrévete con las animaciones! Deberás controlar el renderizado de varios _sprites_ con un cronómetro. Te recomendamos que analices [los ejemplos](https://www.raylib.com/examples.html) de _raylib_. Hay uno específico para animaciones.

5 - Prueba a refactorizar el código (aunque en clase veremos el patrón de diseño clave para desarrollar juegos). 









